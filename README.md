# 高并发抢红包解决方案

## 抢红包原则：

-  尽可能保证每个人能抢到的金额的机率是相同的
- 每个人至少0.01分
- 抢到红包的用户和红包个数相同
- 抢到的金额总和等于红包总金额

## 红包解决方案： 二倍均值法

- 每次能抢到的金额应该在 random{ (0,（剩余金额/剩余红包个数）*2] } 中
- 列如现在有100元，5个红包，第一个人应该在(0,100/5*2] 就是在0-40之间取一个随机数 假如第一个人抢到30，那么第二个人应该在（0,35]之间 假如他抢20元 第三个就是（0，33]  ，他抢了10元，第四个人 （0，40) 之间 ，他抢了15 最后一个人就是 100-30-20-10-15=25

## 高并发实现

首先肯定是redis集群

1. 可以进行数据预热（无锁），在用户发出红包时，就事先计算好每个人强到的金额，把这些金额存到redis的list集合中，然后请求过来时，再依次从list集合中拿，把对应的用户和金额放到map中，缺点：如果我们要考虑并发发红包 ，会增加redis的内存资源消耗

2. 如果是实时计算 、假如有多个用同时点抢红包 ，还是 100 5包 3个人通过二倍均值算法都算到了 能抢35左右 加起来就会超过总金额，这是可以考虑用lua脚本 ，这个lua脚本 就是一个人算完，他会更新数据版本 如果后面的想要操作，发现数据版本不一致，就无法执行，对于拿到之前版本的请求 ，可以让他等一会再拿最新的版本，将这个算好的lua脚本一次发给redis 执行 ，redis在io请求时是并行，在执行操作时，是串行执行
3.  多级缓冲 ，查看领取列表时，有的人可能会点击多次去查看，这时，我们可以在redis缓存后，在内存中存一份缓冲，用户多次查，可以直接在内存中返回原来的数据，不用保证是最新数据，减少了对redis的操作，让redis更多的去执行抢的部分